---
title: 第2节 对象的生命周期初探
date: 2023-02-28 20:32:12
permalink: /pages/b724c2/
author: 
  name: Hao Long
---
## 一、对象的生命周期

在上一小节之中，对于XML的解析阶段已经全部完成，并且已经得到BeanDefinition对象了，并且知道了 BeanDefinition 存储的位置。那么接下来就来考虑一下得到了BeanDefinition 之后，如何完成对象的创建！

这里我们首先对基础课中对象的生命周期进行总结，同样这也是从宏观之上分析对象的生命周期。如果这里面有内容模糊或者是不懂的话，推荐大家去B站搜索《孙哥说Spring》，看一看。

![](img/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.drawio.png)

在这张图之中，对于容器注入，在基础篇的学习过程之中并没有提到，我们接下来就想来看一下

**如果要使用容器级别的注入，需要去实现的Aware接口**，这里列举出最为常见的两种：

- `BeanNameAware`：获取他在工厂中的ID
- `BeanFactoryAware`：获取工厂对象

这里我们演示一下，具体的使用

```java
public class User implements BeanNameAware, BeanFactoryAware {

    private BeanFactory beanFactory;
    
    @Override
    public void setBeanName(String name) {
        System.out.println("name = " + name);

    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
        System.out.println("beanFactory = " + beanFactory);
    }
}
```

![image-20230728212539059](img/image-20230728212539059.png)

这里我标记了一下关键信息，发现 User 类之中拿到的名称为`xml`中配置的ID，拿到的 `BeanFactory` 对象 和 调用的 `BeanFactory` 是一个对象。并且先进行依赖注入，后进行容器级别的注入！那么 容器注入带来了那些用处？

首先，我们来思考一下，scope = ”proroty“ 真的有效吗？，我们来看一下下面这一段代码

```java
public class UserServiceImpl implements UserService {
    private UserDao userDao;

    public UserDao getUserDao() {
        return userDao;
    }
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
    @Override
    public void login(String name, String password) {
        System.out.println(userDao);
    }
}
```

```xml
<bean id="userDao" class="org.example.UserDaoImpl" scope="prototype"></bean>
<bean id="userService" class="org.example.UserServiceImpl">
    <property name="userDao" ref="userDao"/>
</bean>
```

接下来写个测试类测试一下

```java
BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("/applicationContext.xml"));

UserService u1 = (UserService) beanFactory.getBean("userService");
userService.login("haolong","123");

UserService u2 = (UserService) beanFactory.getBean("userService");
userService1.login("haolong","123");

/*
* org.example.UserDaoImpl@31610302
* org.example.UserDaoImpl@31610302
*/
```

通过代码的演示，发现通过注入的方式，并没生效，获取的还是同一个对象，这里就能得出一个结论：通**过注入的形式获取的对象，prototype 无效**，这个问题的解决就可以通过容器注入来解决，下面来演示一下具体的使用场景。

```java
public class UserServiceImpl implements UserService, BeanFactoryAware {
    private BeanFactory beanFactory;
    private UserDao userDao;
    private String username;
    public void setUsername(String username) {
        System.out.println("UserServiceImpl.setUsername");
    }
    
    @Override
    public void login(String name, String password) {
        this.userDao = (UserDao) beanFactory.getBean("userDao");
        System.out.println("UserServiceImpl.login");
    }
    
    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
        System.out.println("UserServiceImpl.setBeanFactory");
    }

    @Override
    public void setBeanName(String name) {
        this.username = name;
        System.out.println("UserServiceImpl.setBeanName");
    }
}
// 测试之后，发现不是同一个对象，问题解决
```

通过这样，我们就能够解决了这样的问题。到这里位置，对象的整个生命周期，我们就讲解完成了，接下来就来看看，对象是如何创建出来的，并且什么进行的创建。

## 二、对象的创建

### 2.1 前言

首先，来回顾一下，从工厂获取对象的过程

```java
// 1. 读取配置文件，并进行BeanDefinition的封装
BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("/applicationContext.xml"));
// 2. 获取对象
User user = (User) beanFactory.getBean("user");
```

对于第二行的代码，意义就是用来获取对象，但是这个方法中到底做了什么？

在这个getbean方法内部，又是调用的是`AbstractBeanFactory`中的 doGetBean方法

```java
@Override
public Object getBean(String name) throws BeansException {
    return doGetBean(name, null, null, false);
}
```

继续看底层实现，源码很长，但是实际上就是两块内容：if 语句块和else语句块，

![image-20230728232702875](img/image-20230728232702875.png)

这里一部分一部分进行阅读

首先，我们来看一看这个方法参数都包含哪些吧

```java
// 方法描述符
protected <T> T doGetBean(
                        String name, // getBean方法中传递过来的名称
                		@Nullable Class<T> requiredType, // 对于最终创建的对象的预期，传入之后，获取对象不强制
                		@Nullable Object[] args,
               			 boolean typeCheckOnly
				)
```

接下来，就来逐步分析一下这个方法之中的代码吧！

```java
String beanName = transformedBeanName(name);
```

这里的name就是我们getBean方法传过来的，一般情况之下就是传过来的name值，但是如果说我们通过别名获取对象，通过这个方法，就能获取对象真正的ID值，这`beanName`就是真正的ID值！

>这里我们举一个通过FactoryBean获取复杂对象的案例
>
>```java
>public class UserService implements FactoryBean<User> {
>    @Override
>    public User getObject() throws Exception {
>        return new User();
>    }
>
>    @Override
>    public Class<?> getObjectType() {
>        return User.class;
>    }
>}
>```
>
>```xml
> <bean id="userService" class="com.haolong.spring.UserService"></bean>
>```
>
>这个时候我们尝试来获取一下对象：
>
>```java
>Object res = beanFactory.getBean("&userService");
>```
>
>![image-20230728233957519](img/image-20230728233957519.png)
>
>这个时候，我们发现，通过这个方法之后，`beanName` 变为了 `userUservice`

```java
Object beanInstance;
Object sharedInstance = getSingleton(beanName);
```

接下来让我们看一下方法的源码：

>当我们点进这个方法的时候，发现是从Map之中依次获取值的过程，首先会从`SingleObjects`中获取，其次会从`earlySingleObjects`中获取，最后从`SingleFactories`中获取，最后返回这个对象！这里其实就是从缓存中获取对象的过程！
>
>```java
>@Nullable
>protected Object getSingleton(String beanName, boolean allowEarlyReference) {
>        // Quick check for existing instance without full singleton lock
>        Object singletonObject = this.singletonObjects.get(beanName);
>        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
>            singletonObject = this.earlySingletonObjects.get(beanName);
>            if (singletonObject == null && allowEarlyReference) {
>                synchronized (this.singletonObjects) {
>                    // Consistent creation of early reference within full singleton lock
>                    singletonObject = this.singletonObjects.get(beanName);
>                    if (singletonObject == null) {
>                        singletonObject = this.earlySingletonObjects.get(beanName);
>                        if (singletonObject == null) {
>                            ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
>                            if (singletonFactory != null) {
>                                singletonObject = singletonFactory.getObject();
>                                this.earlySingletonObjects.put(beanName, singletonObject);
>                                this.singletonFactories.remove(beanName);
>                            }
>                        }
>                    }
>                }
>            }
>        }
>        return singletonObject;
>}
>```
>
>不过只针对于 `scope = singleton`的，Spring会把创建的对象进行缓存，之所以设置这3个Map，是因为要解决循环依赖的问题。
>
>这里我们首先补充一个知识点：<font style="color:black">Spring中创建对象，实际上有两种状态，创建状态和完全体状态</font>
>
>- 创建中：创建出来了，但是不具备使用条件，没有进行初始化和属性填充，仅仅是一个空对象
>- 完全体：对象创建出来了，并进行了属性填充，并执行了初始化

在之后，整体就是两大块内容，if 语句块和 else语句块，这里一部分一部分进行分析

### 2.2 if 语句块

对于这一部分的代码，并不是很长！这个`sharedInstance`，就是我们尝试从缓存之中获取的对象，而这个 args 是从方法参数之中得到的，我们就没传递，默认就是 null。也就是说进入这个代码片段的时候，**说明这个对象之前已经在缓存之中存在了，哪怕他是一个不完全的**

```java
if (sharedInstance != null && args == null) {
    if (logger.isTraceEnabled()) {
        // 判断现在拿到的对象是否是一个完全体对象
        if (isSingletonCurrentlyInCreation(beanName)) {
            logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
                         "' that is not fully initialized yet - a consequence of a circular reference");
        }
        else {
            logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
        }
    }
    // 如果是简单对象，sharedInstance 就是我们最终获取到对象
    // 如果是复杂对象，返回FactoryBean中getObject方法的返回值
    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null);
}
```

这个时候，我们来尝试Debug一遍

```java
BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("/application.xml"));

User user = (User)beanFactory.getBean("user2");

User user1 = (User)beanFactory.getBean("user2");
```

请注意，我们写了两遍`getBean`方法，因为我们发现，第一次的时候，直接走的 `else` 分支，说明并没有进行缓存，或者说这个对象没有被创建过，也说明一点：对于`XmlBeanFactory`工厂，对象的创建过程是在获取的时候！

在第二遍才能从Map之中获取，我们这个时候发现，beanInstance 直接从才缓存之中拿了

### 2.3 else语句块

分析完成 if语句块 之后，我们就开发分析 else 语句块

1）这段代码就是一段安全性验证

```java
// Fail if we're already creating this bean instance:
// We're assumably within a circular reference.
if (isPrototypeCurrentlyInCreation(beanName)) {
    throw new BeanCurrentlyInCreationException(beanName);
}
```

这个语句块用来解决父子容器的问题，如果说子容器中没有，并且有父容器，才回去递归去父容器中去找

```java
// 1. 解决父子容器的问题，最为常见的父子容器就是  MVC
// 2. 如果说子容器和父容器中有相同的配置，以子容器为主
BeanFactory parentBeanFactory = getParentBeanFactory();
// 3. 如果说父容器不为null，并且说子容器中没有这个ID，则进入这个语句块，去递归实例化父容器
if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
    // Not found -> check parent.
    String nameToLookup = originalBeanName(name);
    if (parentBeanFactory instanceof AbstractBeanFactory) {
        return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
            nameToLookup, requiredType, args, typeCheckOnly);
    }
    else if (args != null) {
        // Delegation to parent with explicit args.
        return (T) parentBeanFactory.getBean(nameToLookup, args);
    }
    else if (requiredType != null) {
        // No args -> delegate to standard getBean method.
        return parentBeanFactory.getBean(nameToLookup, requiredType);
    }
    else {
        return (T) parentBeanFactory.getBean(nameToLookup);
    }
}
```

这个 typeCheckOnly，方法参数中的默认传递过来的是false:

- 如果是 false，Spring会创建对象，或者获得对象，返回给调用者
- 如果是 true，只进行类型判断，而不是获取对象

```java
if (!typeCheckOnly) {
    // 1. 想让Spring创建对象,标记这个对象是需要创建的
    // 1.1 标记这个类需要被创建
    // 1.2 清空被合并的BeanDefinition 里面 clearMergeBeanDefinition(beanName)
    // 如果创建他，他就已经是一个已经被合并好了的，不能曾经被合并过
    markBeanAsCreated(beanName);
}
StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate")
					.tag("beanName", name);
```

requiredType是方法参数中传递过来的，表示要获取的对象的类型

```java
if (requiredType != null) {
    beanCreation.tag("beanType", requiredType::toString);
}
```

将父子对象进行合并，这个mbd最终就是合并好的对象

```java
/**
*  <bean id="s" class="org.example.Student" abstract="true">
*    <property name="username" value="haolong"/>
*   <property name="password" value="1234456"/>
* </bean>
* <bean id="st" class="org.example.Student" parent="s"/>
* 相当于将这两段配置进行合并，最终合并成为了RootBeanDefinition
*/
RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
```

安全性检查，防止工厂中都是抽象的bean

```java
checkMergedBeanDefinition(mbd, beanName, args);
```

处理：`<bean depend-on="">`的这种情况，这里举一个实例，

> ```java
> <bean id="gg" class="org.example.GG"></bean>
> <bean id="ff" class="org.example.FF" depends-on="gg"></bean>
> ```

```java
// 处理<bean  depend-on="">
String[] dependsOn = mbd.getDependsOn();
if (dependsOn != null) {
    for (String dep : dependsOn) {
        if (isDependent(beanName, dep)) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                            "Circular depends-on relationship between '"
                                            + beanName + "' and '" + dep + "'");
        }
        registerDependentBean(dep, beanName);
        try {
            getBean(dep);
        }
        catch (NoSuchBeanDefinitionException ex) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                            "'" + beanName + 
                                            "' depends on missing bean '" + dep + "'", ex);
        }
    }
}
```

接下来，就是创建对象的过程了，分为singleton对象和protype对象，这里首先来分析一下singleton对象:

```java
if (mbd.isSingleton()) {
    sharedInstance = getSingleton(beanName, () -> {
        try {
            return createBean(beanName, mbd, args);
        }
        catch (BeansException ex) {
            // Explicitly remove instance from singleton cache: It might have been put there
            // eagerly by the creation process, to allow for circular reference resolution.
            // Also remove any beans that received a temporary reference to the bean.
            destroySingleton(beanName);
            throw ex;
        }
    });
    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}
```

>首先，来分析一下这里的 `getSingleton` 方法
>
>```java
>public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
>    Assert.notNull(beanName, "Bean name must not be null");
>    synchronized (this.singletonObjects) {
>        // 首先，会尝试从缓存中获取对象，如果说能拿到，直接返回，，如果没有拿到则进入后面的步骤
>        Object singletonObject = this.singletonObjects.get(beanName);
>        if (singletonObject == null) {
>            if (this.singletonsCurrentlyInDestruction) {
>               throw new BeanCreationNotAllowedException(beanName,
>				"Singleton bean creation not allowed while singletons of this factory are in destruction " 					+
>				"(Do not request a bean from a BeanFactory in a destroy method implementation!)");
>            }
>            if (logger.isDebugEnabled()) {
>                logger.debug("Creating shared instance of singleton bean '" + beanName + "'");
>            }
>            // 实际上是状态的判断
>            // 这个bean没有被排除，并且说这个bean正在创建中,只有满足这两个条件，这个bean才可以被创建
>            beforeSingletonCreation(beanName);
>            boolean newSingleton = false;
>            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
>            if (recordSuppressedExceptions) {
>                this.suppressedExceptions = new LinkedHashSet<>();
>            }
>            try {
>                // 等同于回调createBean方法
>                // 在Create方法中：
>                // 首先会获取这个对象的Class对象，其次会进行方法的覆盖
>                singletonObject = singletonFactory.getObject();
>                newSingleton = true;
>            }
>            // 这里把Catch语句块删除，方便看
>            finally {
>                if (recordSuppressedExceptions) {
>                    this.suppressedExceptions = null;
>                }
>                afterSingletonCreation(beanName);
>            }
>            if (newSingleton) {
>                addSingleton(beanName, singletonObject);
>            }
>        }
>        return singletonObject;
>    }
>}
>```
>
>



在上述代码中，我们只需要关注三个核心方法：

> 核心方法一： `beforeSingletonCreation(beanName);`

在这个方法中，实际上是状态的判断，如果这个bean没有被排除，并且说这个bean正在创建中,只有满足这两个条件，这个bean才可以被创建

> 核心方法二：`singletonObject = singletonFactory.getObject();`

这就是创建对象的核心`getObject`方法，而他又是回调了lambda表达式中的`createBean`方法，而在createBean方法中

- 首先会进行Class对象的获取
- 其次会去进行方法的覆盖（xml中写`lookup-method`和`replaced-method`）
- 创建对象

```java
Object beanInstance = doCreateBean(beanName, mbdToUse, args);
```

而在这个方法内部，核心代码又是下面这3行：

```java
// 创建对象
BeanWrapper instanceWrapper = createBeanInstance(beanName, mbd, args);

// 属性填充，set注入或者自动注入，对于构造注入，是在创建对象的时候进行注入的
populateBean(beanName, mbd, instanceWrapper);

// 初始化操作
exposedObject = initializeBean(beanName, exposedObject, mbd);
```

方法一：对于这个`BeanWrapper`，在里面存储了我们的对象和对象的属性所需要的类型转换器，注意这里对象和属性是分开的，方便于我们后续的操作。在这个方法的内部核心，就是通过默认的无参创建对象

```java
return instantiateBean(beanName, mbd);
```

方法二：里面涉及到了类型的转换，最终是通过反射来调用set方法

- 对于`bean`标签中的内容，封装为了TypeStringValue
- 对于引用类型，封装为了RuntimeBeanReferences
- 对于自动注入

如果说我们进行属性填充的时候，如果说个这个类型是自定义类型，就会再一次通过BeanFactory进行去获取

```java
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
    if (bw == null) {
        if (mbd.hasPropertyValues()) {
            throw new BeanCreationException(
                mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");
        }
        else {
            // Skip property population phase for null instance.
            return;
        }
    }

    // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
    // state of the bean before properties are set. This can be used, for example,
    // to support styles of field injection.
    if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
        for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
            if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                return;
            }
        }
    }

    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

    int resolvedAutowireMode = mbd.getResolvedAutowireMode();
    if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
        // Add property values based on autowire by name if applicable.
        if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
            autowireByName(beanName, mbd, bw, newPvs);
        }
        // Add property values based on autowire by type if applicable.
        if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
            autowireByType(beanName, mbd, bw, newPvs);
        }
        pvs = newPvs;
    }

    boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
    boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

    PropertyDescriptor[] filteredPds = null;
    if (hasInstAwareBpps) {
        if (pvs == null) {
            pvs = mbd.getPropertyValues();
        }
        for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
            PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                if (filteredPds == null) {
                    filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                }
                pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
                if (pvsToUse == null) {
                    return;
                }
            }
            pvs = pvsToUse;
        }
    }
    if (needsDepCheck) {
        if (filteredPds == null) {
            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
        }
        checkDependencies(beanName, mbd, filteredPds, pvs);
    }

    if (pvs != null) {
        applyPropertyValues(beanName, mbd, bw, pvs);
    }
}
```

方法三：用来确保单实例



通过这样的分析，我们发现创建对象是在用的时候才进行创建，但是我们在Spring基础课的时候，学到了单实例对象是在工厂创建的时候进行创建，但是通过现在的分析，我们发现是通过`getBean`方法调用的时候，才进行创建，出现这里原因的问题，在于我们实现的工厂不同：在基础课我们所学的工厂是Spring中的高级工厂`ApplicationContext`，但是这里分析的实际上是一个底层的工厂`DefaultListableBeanFactory`，而ApplicationContext实际上是对这个工厂的封装，并在这个工厂之上添加了一些信息，这也就造成了这样的现象。

## 三、循环依赖

Spring 中所能解决的问题，就是**两个对象都是单实例的，并且两个对象都是通过set注入的方式才能够成功**。注意，以下情况是不可以的

- 如果说两个对象都是单实例的，但是通过构造注入的方式，是不可以的
- 如果说两个对象都是多实例的，不管哪种方式都是不可以的

首先，这里分析一下循环引用的问题，比方说A 中引用了B，B中共引用了A，这就造成了循环引用，在创建对象的时候，就造成了死循环。并且在下图中共给出了流程

![](img/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A801.drawio.png)

在上图的分析过程中，我们将一个半成品的对象，放在了一个Map中，就解决了循环引用的问题，那么在Spring中到底是如何进行实现的？



![](img/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.drawio.png)

分析完成！



