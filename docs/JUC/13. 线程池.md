---

---



## 一、概述

在Java之中，我们通过`new Thread() `很轻松的创建一个线程，但是在底层却是需要去调用操作系统内核的API，由操作系统为线程分配一系列资源。所以创建他的成本很高，应该避免去重复的进行创建和销毁。

对于这种需要频繁的创建和销毁的东西，最为常见的思想就是：进行池化。对于一般意义上的池化资源，都是在需要的时候调用`acquire`进行资源的申请，使用完成之后，调用`release`进行资源的释放。不过在线程池的设计之上，并没有采用这样的池化思想的设计，而是采用了 **生产-消费者模型**，如图所示：

![image-20230611172924380](img/image-20230611172924380.png)

我们将线程池的使用者作为生产者向队列之中，不断推送需要进行异步执行的任务，而线程池不断从队列之中，获取任务来执行。

```java
/**
 * @project: Study-JUC
 * @description:
 * @author: haolong
 * @data: 2023/6/11 16:57
 */
public class MyThreadPool {
    // 利用阻塞队列实现生产者消费者模型
    BlockingQueue<Runnable> workQueue;
    // 保存内部的工作线程
    List<WorkThread> threads;
    /**
     * 自定义线程池的构造方法
     * @param poolSize 内部工作线程的数量
     * @param workQueue 阻塞队列
     */
    MyThreadPool(int poolSize,BlockingQueue<Runnable> workQueue) {
        this.workQueue = workQueue;
        threads = new ArrayList<>(poolSize);
        for (int i = 0; i < poolSize; i++) {
            WorkThread workThread = new WorkThread();
            workThread.start();
            threads.add(workThread);
        }
    }
    /**
     * 提交任务
     * @param command
     */
    void execute(Runnable command) throws InterruptedException {
        workQueue.put(command);
    }
    /**
     * @project: Study-JUC
     * @description: 工作线程，负责消费任务，并执行任务
     * @author: haolong
     * @data: 2023/6/11 16:58
     */
    class WorkThread extends Thread{
        @Override
        public void run() {
            while (true) {
                try {
                    Runnable task = workQueue.take();
                    task.run();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

在我们执行了上述代码之后，其实感觉并不难！


线程池做的工作：只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过最大数量，超过数量的线程排队等待，等其他线程执行完毕之后，再从队列中取出任务来执行
特点

- 提高线程的利用率
- 提高线程的响应速度
- 便于统一管理线程对象
- 可以控制最大并发数

![IMG_1153.PNG](img/1661235634141-e21629aa-c99f-4bfb-9ebf-24287cd0da5d.png)
## 二、类图详解
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661233710732-c0671071-76e0-4e8f-9425-7401a054881c.png#averageHue=%232a2b31&clientId=uc40a7392-e19c-4&from=paste&height=524&id=RiKfC&originHeight=668&originWidth=1129&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26226&status=done&style=none&taskId=uc6e17050-7f58-425f-b9af-7c82dba34e8&title=&width=885.4902126366525)
### 2.1 Executor
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661234005635-c4e82f9f-86fe-428a-9ca8-c949285a6647.png#averageHue=%23292a30&clientId=uc40a7392-e19c-4&from=paste&height=409&id=ZV5eN&originHeight=521&originWidth=1258&originalType=binary&ratio=1&rotation=0&showTitle=false&size=64939&status=done&style=none&taskId=u6fe72e93-2988-45c0-9a8c-457f0aa233c&title=&width=986.6666851168368)
在这个接口之中，只有一个方法，接受一个`Runnable`的实例，他用来执行一个任务，注意只能是Runnable。他创建线程是异步执行的，也就是说，不用等待每个任务执行完毕后在执行下一个任务。
`executor`方法代替了显示创建线程的方式，通过这种方式创建的线程是异步执行的，也就是说，你不用等待每个任务执行完成之后在执行下一个任务。
```java
class Task implements Runnable{
    @Override
    public void run() {
        System.out.println("Task.run");
    }
}
public class ExecutorTest {
    public static void main(String[] args) {
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(new Task());
    }
}
```
这样的代码会一直不会停止
Executor只需要关心发布命令，并且说线程不需要回报，所以说我们需要认识其他管家，管他这个线程的其他事务，比如什么时候终止，什么时候暂停，当前的状态等
### 2.2 ExecutorService
`Executor`接口的实现类，提供了一些`Executor`中没有的方法，在这个方法列表之中，我们发现，在这个类中，还可以接受`Callable`对象
![方法](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661239473442-7b18a90f-b2ab-435e-ae84-75705f5d5e6b.png#averageHue=%23353738&clientId=u0e49b13b-0b99-4&from=paste&height=335&id=ud8bbf56b&originHeight=427&originWidth=1016&originalType=binary&ratio=1&rotation=0&showTitle=true&size=56660&status=done&style=none&taskId=ua234b613-9248-484b-b4b1-0dbed16ce8e&title=%E6%96%B9%E6%B3%95&width=796.8627599989716 "方法")
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661240117127-f98e6877-d104-405d-93c8-510b59d0e00e.png#averageHue=%232f3036&clientId=u0e49b13b-0b99-4&from=paste&height=610&id=u5be6e0a0&originHeight=778&originWidth=1261&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90071&status=done&style=none&taskId=ue6792e9d-a395-4a8e-a0d3-598f6adbe90&title=&width=989.0196263373062)
`shutdown()`

1. 调用之后，**会有序关闭正在执行的任务，没有执行的任务会被中断，正在执行的任务会继续执行下去，但是不接受新任务**。如果任务已经关闭，该方法不会产生任何影响
2. 只是将线程池的状态设置为`SHUTDOWN`

`shutdownNow()`

1. **会尝试停止关闭所有正在执行的任务，停止正在等待的任务，并返回正在等待执行的任务列表**
2. 只是将线程池的状态设置为`STOP`，正在执行和等待的任务就会被停止，返回等待执行的任务列表

`isShutdown()`

1. 执行器是否已经关闭，如果关闭了，返回true，否则，返回false

`isTerminated()`

1. 所有任务在关闭后是否已经完成，如果完成了返回false
2. 除非调用`shutdown`或者`shutdownNow`方法，否则，永远返回false

`awaitTermination()`

1. 阻塞，直到发出`shutdown`请求后所有的任务已经完成执行后才会解除

`submit()`：注意这里返回值是正对于`Callable`才有意义的，如果说返回`Integer`，返回值最终就是`Future<Integer>`
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661239987280-5a4bcce1-d1b4-4cca-84b4-67c6c83ad7e9.png#averageHue=%232c2f35&clientId=u0e49b13b-0b99-4&from=paste&height=543&id=u2dfe3e93&originHeight=692&originWidth=1288&originalType=binary&ratio=1&rotation=0&showTitle=false&size=95037&status=done&style=none&taskId=ue0220b83-ccc2-4047-a0d5-e1f024b7fb3&title=&width=1010.1960973215308)

6. `invokeAll`：执行给定的任务列表，执行完成后会返回一个任务列表
7. `invokeAny`：获取最先完成任务的结果
### 2.3 AbstractExecutorService 
抽象类，会分析`ExecutorService`这个类的工作，正对要求做一些规划，然后找他的得力助手，`ThreadPoolExecutor`来完成目标
实现了ExecutorService中`invokeAll`和`invokeAny`方法
### 2.4 ScheduledExecutorService
接口，他就是一个定时执行器，可以安排命令在一定延迟时间只有运行或者定期执行

1. 这两个方法就是两个重载方法，能够延迟一定时间之后执行任务，并且只会执行一次，返回值表示了异步延迟处理的结果

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661826494094-5ee37022-0d80-4e6e-b405-b6e79ac4a1a8.png#averageHue=%232c2f35&clientId=u4b49e335-7eba-4&from=paste&height=227&id=u34eff3cf&originHeight=289&originWidth=1168&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40822&status=done&style=none&taskId=ua3880392-fd0f-418f-a656-9960d4160f0&title=&width=916.0784485027547)

2. 表示任务会按照固定的频率在时间`initialDelay`之后不断执行

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661826575490-9ed9b208-a7b7-4f17-bb78-841878f9cdee.png#averageHue=%232a2b32&clientId=u4b49e335-7eba-4&from=paste&height=167&id=uafd5d50f&originHeight=213&originWidth=1123&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22889&status=done&style=none&taskId=u084ee766-8cb2-448b-8451-127bbe7f2a2&title=&width=880.7843301957137)
```java
Runnable command = () -> {
    long start = System.currentTimeMillis();
    System.out.println("current Time:\t"+start);
    try {
        TimeUnit.MILLISECONDS.sleep(new Random().nextInt(100));
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("time speed = "+(System.currentTimeMillis() - start));
};
ScheduledExecutorService se = Executors.newScheduledThreadPool(10);
System.out.println(System.currentTimeMillis());
se.scheduleAtFixedRate(command,100,1000,TimeUnit.MILLISECONDS);
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661827006715-381b36c4-d513-48ff-a0e0-a698ea77a7bf.png#averageHue=%232c2c2b&clientId=u4b49e335-7eba-4&from=paste&height=294&id=u6421fe99&originHeight=375&originWidth=1046&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34303&status=done&style=none&taskId=u49ce369e-2bb0-4a0d-a9b7-0ee862093bd&title=&width=820.3921722036656)

3. 表示以固定延迟时间的方式来执行任务

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661826716062-58badea0-9422-46f0-970a-4c0acdb3a59f.png#averageHue=%23292b31&clientId=u4b49e335-7eba-4&from=paste&height=165&id=u89413a0d&originHeight=210&originWidth=1173&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23130&status=done&style=none&taskId=u2a528486-6167-4042-b453-6c3b7aa52ea&title=&width=920.000017203537)
## 三、 Executors
创建线程的工具类，可以使用静态工厂方法来创建线程池
![IMG_1154.PNG](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661235874269-536f888e-e05f-4635-839a-0ec17c10070d.png#averageHue=%23fdfefc&clientId=uc40a7392-e19c-4&from=paste&height=765&id=A91Ws&originHeight=976&originWidth=1564&originalType=binary&ratio=1&rotation=0&showTitle=false&size=359987&status=done&style=none&taskId=u76c0cbc4-f134-4cf7-aeb0-8c4f6b0da44&title=&width=1226.666689604716)
这些线程池的底层实现都是有`ThreadPoolExecutor`来提供支持的

1. 对于`FixedThreadPool`，核心线程数和最大线程数是一样的，选取的是LinkedBlockingQueue，如果说我们处理任务的速度比较慢，随着请求的增加，队列中积压的任务就会越来越多，最终大量积压的任务就会占用大量的内存，发生OOM
2. 对于`SingleThreadExecutor`，使用唯一的线程去执行任务，选取的是LinkedBlockingQueue，任务积压，发生OOM
3. 对于`CachedThreadPool`，线程数几乎可以无限增加，当线程闲置的时候，还可以对线程进行回收。选取的是`SynchronousQueue`，并不会控制线程的数量，就会导致创建非常多的线程，最终超过操作系统的上限而无法创建新的线程，或者导致内存不足
4. 对于`newWorkStealingPool`，基于Java的Fork-Join进行实现
> 为什么不推荐使用上述的方式

提供的很多方法默认使用的都是无界的`LinkedBlockingQueue`，高负荷情况之下，无界队列很容易导致 OOM，而OOM会导致所有的请求都无法处理。
> **线程池如何实现线程的复用？**

线程池中采用一个生产者消费者的模式，
> **线程池如何知道一个线程的任务已经完成？**

通过同步调用run方法，并且
## 四、ThreadPoolExecutor
问题：

- 自身有哪些状态？如何维护这些状态
- 如何维护内部的工作线程
- 处理任务的整体流程是怎样的？
### 4.1 构造函数
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661240688558-e3d655af-c626-46bf-bee3-dde5a8d815a4.png#averageHue=%23353839&clientId=u0e49b13b-0b99-4&from=paste&height=104&id=zAmDs&originHeight=132&originWidth=992&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22784&status=done&style=none&taskId=uce9e0c41-3c08-4a4c-91a7-5d5fefd8f36&title=&width=778.0392302352163)
虽然说提供了四种构造函数，但是本质上还是调用最后一个构造函数。所以直接学习最后一个构造函数即可
```java
new ThreadPoolExecutor()

    corePoolSize, // 线程池的基本大小

    maximumPoolSize, // 最大线程数量

    keepAliveTime, // 线程的存活时间

    millseconds, // 时间单位

    threadFactory,// 线程工厂，用来创建线程

    runnableTaskQueue,// 等待队列

    handler // 拒绝策略
;
```

1. `corePoolSize`：核心线程池的容量大小。可以被看做成稳定的工作线程数

![IMG_1187.PNG](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661828369639-b3e79a89-c86e-4d94-a3b3-65bff7df455e.png#averageHue=%23fcfcfc&clientId=u4b49e335-7eba-4&from=paste&height=947&id=udee39dfa&originHeight=1208&originWidth=1674&originalType=binary&ratio=1&rotation=0&showTitle=false&size=287736&status=done&style=none&taskId=u87a5cddf-b462-4acd-841b-2943c5570d6&title=&width=1312.9412010219276)

2. `maximumPoolSize`
3. `keepAliveTime`：线程池的保活机制，**表示线程在没有任务执行的情况之下保持多久会被终止**，在默认情况之下，这个参数只有在线程数量大于corePoolSize时才会生效。
4. `millseconds`
5. `threadFactory`：线程工厂，用于创建线程
6. `workQueue`
   1. 等待队列，如果说任务线程 > corePoolSize的时候，就会把任务放入到阻塞队列中
   2. `SynchronousQueue`
   3. `LinkedBlockingQueue`
   4. `ArrayBoockingQueue`
7. `handler`：拒绝策略

![IMG_1155.PNG](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661236626469-0da2301a-f908-4225-a418-c0472700bbec.png#averageHue=%23fceddd&clientId=uc40a7392-e19c-4&from=paste&height=742&id=ueaf482be&originHeight=946&originWidth=1308&originalType=binary&ratio=1&rotation=0&showTitle=false&size=91543&status=done&style=none&taskId=u84722dc6-6ae6-485f-8f42-10e9b66f224&title=&width=1025.8823721246602)

- `AbortPolicy`：丢弃任务并抛出 RejectedExecutionException 异常，让你感知到任务被拒绝了，越是你可以根据业务逻辑选择重试或者放弃提交等策略
- `DiscardPolicy`: 直接丢弃任务，但是不抛出异常，相对而言处在一定的风险，因为我们提交之后根本不知道这个任务被丢弃了，可能造成数据的丢失
- `DiscardOldestPolicy`：如果线程池没有被关闭，并且没有能力执行，则直接丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。
- `CallerRunsPolicy`：这种机制相对而言比较完善，当有新的任务提交的时候，如果说线程池没有被关闭且没有能力执行，则由调用线程处理该任务，也就是说谁提交的，谁负责执行任务
### 4.2 状态
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661838358379-3e6bd5e2-c57f-4095-9990-ca686ae6834f.png#averageHue=%232a2c33&clientId=uc2ed66ee-12a4-4&from=paste&height=266&id=u5954a1d8&originHeight=339&originWidth=1121&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58169&status=done&style=none&taskId=u156900b3-bbf9-4208-88dc-21977fe309f&title=&width=879.2157027154007)
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661838145357-5ca0bee7-93ef-4dd4-958b-8b92d97f0737.png#averageHue=%232c2b2b&clientId=uc2ed66ee-12a4-4&from=paste&height=308&id=u64f41de6&originHeight=393&originWidth=1626&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19161&status=done&style=none&taskId=u35e331c8-1944-4f32-a1b0-8c7594fb48e&title=&width=1275.294141494417)
通过对这几个值的二进制表示进行打印，发现**线程的状态只用了高3位，而工作线程数使用了低29位进行表示**
我们通过一个原子操作类来包含**线程池的状态以及池中工作线程池数**，线程池状态位于高位
线程的状态

- `running`：接受新任务，也能处理阻塞队列中的任务
- `shutdown`：不接受新任务，但是处理阻塞队列中的任务
- `stop`：不接受新任务，不处理阻塞队列中的任务，中断处理过程中的任务
- `tidying`：所有任务执行完成，并且线程池中没有工作线程，并且将要调用`terminated`方法
- `triminated`：线程池彻底结束

![线程池状态](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661238332638-83710c3e-6204-4230-ae6d-72bde74db967.png#averageHue=%23f8ede9&clientId=uc40a7392-e19c-4&from=paste&height=260&id=ucb85617f&originHeight=332&originWidth=1283&originalType=binary&ratio=1&rotation=0&showTitle=true&size=53226&status=done&style=none&taskId=u0dadd508-c769-487a-87ae-3aa86fcd635&title=%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81&width=1006.2745286207485 "线程池状态")
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661838411802-acaf50e1-a329-487c-9a88-878a96bdc2e3.png#averageHue=%232a2e35&clientId=uc2ed66ee-12a4-4&from=paste&height=43&id=u574fb030&originHeight=49&originWidth=872&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12784&status=done&style=none&taskId=u27875c98-62a4-475e-a429-37d14905b71&title=&width=762.9215698242188)
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661838427697-c7706920-2caf-44c5-97f7-7b3d1771d073.png#averageHue=%232a2b32&clientId=uc2ed66ee-12a4-4&from=paste&height=40&id=u5adeeec4&originHeight=43&originWidth=876&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6886&status=done&style=none&taskId=ub519690b-e8a9-4c9b-9189-d1efc10ed2e&title=&width=805.058837890625)
ctl ，就是组合了线程池的状态和池中工作线程数两个信息的变量，初始化的时候调用了ctlof方法，将工作线程标记为了`RUNNING`状态，并且工作线程数为0，结果如下：
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661838643281-3bcfa90e-bdf5-473c-b231-4812243dc266.png#averageHue=%232d2c2b&clientId=uc2ed66ee-12a4-4&from=paste&height=27&id=u48e75bf6&originHeight=35&originWidth=1415&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1376&status=done&style=none&taskId=u4c03e801-46a0-4510-b88b-8c1a64f7207&title=&width=1109.8039423214022)
### 4.3 内部类
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661841485241-04b9c454-8361-4fa4-9381-d31c41427708.png#averageHue=%23292b32&clientId=uc2ed66ee-12a4-4&from=paste&height=94&id=uc010e7f3&originHeight=120&originWidth=1154&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14566&status=done&style=none&taskId=ud6d4b488-6a30-46c6-b5f8-a6a13c9b0c3&title=&width=905.0980561405642)
继承`AQS`，说明了这个类的内部有同步需求，实现Runnable接口，说明这个类本身就是一个异步的任务调动者。
### 4.4 变量
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661241116170-b208d663-fbc4-4dfa-a5a5-895fc0e7171b.png#averageHue=%23292d34&clientId=u0e49b13b-0b99-4&from=paste&height=38&id=u6a35ce5f&originHeight=49&originWidth=972&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8214&status=done&style=none&taskId=u3cb6f597-8a75-44d1-b235-6a5ad6d3d5b&title=&width=762.3529554320869)

- 构造函数传入之后，会赋值给该变量

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661241163077-f7346053-49b4-4aab-b3ff-be3eed624d99.png#averageHue=%232a2d34&clientId=u0e49b13b-0b99-4&from=paste&height=38&id=u3450d0ba&originHeight=48&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9341&status=done&style=none&taskId=u413484bd-043a-4c1a-82c0-9651595f120&title=&width=784.313740156468)

- 状态锁，如果说对线程池的状态进行改变都需要用到

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661241228394-17e54af2-6a53-4af4-bc39-3df2832b554b.png#averageHue=%23292c33&clientId=u0e49b13b-0b99-4&from=paste&height=36&id=u560ffc1c&originHeight=46&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7165&status=done&style=none&taskId=u628e7fe0-22f2-4abd-b09e-d078c4eabcc&title=&width=814.1176622824138)

- 线程工厂，所有的线程都会使用该工厂进行创建，调用`addWorker()`创建
### 4.5 处理
![61dd5add13b0f9413ed63cc83479023f.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661241321320-1ec1dd05-88d7-4618-927a-55d4bb1ec99d.png#averageHue=%23fcf1e8&clientId=u0e49b13b-0b99-4&from=paste&height=577&id=ue81cf478&originHeight=736&originWidth=1574&originalType=binary&ratio=1&rotation=0&showTitle=false&size=154318&status=done&style=none&taskId=ue0525bb7-138d-4452-9ea0-74f5b82ac69&title=&width=1234.5098270062806)

- 如果说线程池的核心数量小于`corePoolSize`，就会通过`addWorker`创建新的线程，如果说成功了，直接返回

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661830588748-8ac3ebe7-bc4c-42a6-9638-5de1f4793382.png#averageHue=%23292c32&clientId=u4b49e335-7eba-4&from=paste&height=595&id=u974e43aa&originHeight=759&originWidth=1187&originalType=binary&ratio=1&rotation=0&showTitle=false&size=145692&status=done&style=none&taskId=ubcee5e84-a01f-42eb-9846-849e45b794b&title=&width=930.9804095657275)
![IMG_1189.PNG](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661829201573-72158daa-f59c-43d6-834b-de446a70aa1c.png#averageHue=%23f8f6f0&clientId=u4b49e335-7eba-4&from=paste&height=936&id=u3fcf58b4&originHeight=1194&originWidth=1584&originalType=binary&ratio=1&rotation=0&showTitle=false&size=354398&status=done&style=none&taskId=u24a09b33-607c-45be-a03f-b67a0217cf8&title=&width=1242.3529644078453)

![IMG_1190.PNG](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661829334534-4e351578-b609-45cb-870e-f1dc1afec983.png#averageHue=%23f9f8f3&clientId=u4b49e335-7eba-4&from=paste&height=922&id=u1dd54237&originHeight=1176&originWidth=1618&originalType=binary&ratio=1&rotation=0&showTitle=false&size=336154&status=done&style=none&taskId=u09f8f1b8-1694-4207-af9a-27943ebf9a5&title=&width=1269.0196315731653)

## 五、实战案例

> 多线程实现文件的导出



> 线程池 + GRPC 实现日清功能