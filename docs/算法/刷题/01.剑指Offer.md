---
title: 剑指Offer
date: 2023-06-08 21:16:38
recommend: 1
tag:
 - 刷题
---

## 剑指 Offer 03. 数组中重复的数字

>  [剑指 Offer 03. 数组中重复的数字](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

算法实现一：通过排序之后，整个数组就是有序的。通过对数组进行遍历，如果说当前元素和后面一个元素是一样的，说明该元素就是重复的，直接返回即可。
时间复杂度：`O(nlogn)`
```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        for(int i = 0; i < n - 1;i++ ) {
            if(nums[i] == nums[i+1]) return nums[i];
        }
        return  -1;
    }
}
```
算法二：通过题目，我们发现数组中的元素都是正整数，可以使用桶排序的思想。将nums[i] 放在st数组的指定位置之上，也就是说`st[nums[i]]++`，如果说添加之后元素的值超过了2，可以说明该元素重复，直接返回即可。
时间复杂度：`O(n)`
```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        int n = nums.length;
        int[] st = new int[n + 1];
        for(int i = 0; i < n; i++) {
            if(++st[nums[i]] > 1) return nums[i];
        }
        return -1;
    }

```
算法三：使用下标法。通过不停交换数组中的元素，使得元素和他所对应的下标相等。也就是`nums[i] = i`
```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        int n = nums.length;
        for(int i = 0; i < n; i++) {
            while(nums[i] != i) {
                if(nums[i] == nums[nums[i]]) {
                    return nums[i];
                }
                int k = nums[nums[i]];
                nums[nums[i]] = nums[i];
                nums[i] = k;
            }
        }
        return -1;
    }
}
```
## 剑指 Offer 04. 二维数组中的查找
> 原题链接：[剑指 Offer 04. 二维数组中的查找](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

算法实现一：暴力枚举
时间复杂度：`O(n * m)`
```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        int n = matrix.length;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j <  matrix[i].length; j++) {
                if(matrix[i][j] == target) {
                    return true;
                }
            }
        }
        return false;
    }
}
```
算法实现二：二分
题目中已经说明了，每一行都是一个递增的序列，通过这一点，我们可以很容易想到用二分。对于每个行都进行一次二分即可。
时间复杂度：O(nlogn)
```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        int n = matrix.length;
        for(int i = 0; i < n; i++) {
            if(matrix[i].length == 0) continue;
            if(check(matrix[i],target)) {
                return true;
            }
        }
        return false;

    }
    private boolean check(int[] arr,int target) {
        int l = 0;
        int r = arr.length - 1;
        while(l < r) {
            int mid = l + r + 1 >> 1;
            if(arr[mid] <= target) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return arr[l] == target;
    }
}
```
算法实现三：这种做法就是根据他每一行，每一列的特性来进行计算，如果说目标值比这一行的最后一个元素都大，那么这一行就不可能存在目标值。如果说目标值比当前列的这个元素都小，那么这一列就不可能存在目标值。
时间复杂度：`O(n + m)`
```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
        int n = matrix.length;
        int m = matrix[0].length;
        int col = 0;
        int row = m - 1;
        while(col < n && row >= 0) {
            if(matrix[col][row] < target) {
                col++;
            } else if(matrix[col][row] > target) {
                row--;
            } else {
                return true;
            }
        }
        return false;
    }
}
```
## 剑指 Offer 05. 替换空格
> 原题链接：[剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

使用StringBuffer即可。
```java
class Solution {
    public String replaceSpace(String s) {
        StringBuffer sb = new StringBuffer();
        for(int i = 0; i < s.length(); i++) {
            if(s.charAt(i) == ' ') {
                sb.append("%20");
            } else {
                sb.append(s.charAt(i));
            }
        }
        return sb.toString();
    }
}
```
## 剑指 Offer 06. 从尾到头打印链表
> 原题链接：[剑指 Offer 06. 从尾到头打印链表](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

对于这个题，最普遍的做法就是遍历一遍链表，将所有节点的值，都添加到集合中，最后对集合进行反向遍历，存到数组中即可。这样做的时间复杂度是`O(n ^ 2)`。
我们首先可以使用一个变量`len`来进行链表中元素个数的统计，然后在进行一次链表的遍历，将链表中第0个位置的元素放在数组的`len - 1`的位置之上(数组中是从0开始存储元素)，将链表中第1个位置放在数组`len - 2`的位置之上。
```java
class Solution {
    public int[] reversePrint(ListNode head) {
        ListNode tem = head;
        int len = 0;
        while(tem != null) {
            len++;
            tem = tem.next;
        }
        int[] res = new int[len];
        tem = head;
        while(tem != null) {
            res[--len] = tem.val;
            tem = tem.next;
        }
        return res;
    }
}
```
## 剑指 Offer 07. 重建二叉树
> 原题链接：[剑指 Offer 07. 重建二叉树](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)

1. 通过先序遍历，可以知道根节点是谁，但是不知道左右子树的大小
2. 通过中序遍历，我们可以知道左右子树的节点个数

![image.png](img/1660732866312-872665c0-3206-4287-b5d6-e72ee87b8e82.png#clientId=u9b444c32-c4e9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=358&id=ua1c7072b)
```java
class Solution {
    private int[] preorder;
    private int[] inorder;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        this.inorder = inorder;
        return build(0,preorder.length - 1,0,inorder.length - 1);
    }
    private TreeNode build(int l1,int r1,int l2,int r2) {
        // 序列已经完了，返回即可
        if(l1 > r1) return null;
        TreeNode root = new TreeNode(preorder[l1]);
        int mid = 0;
        // 通过中序遍历，获取根节点的位置
        for(int i = l2; i < inorder.length; i++) {
            if(inorder[i] == root.val) {
                mid = i;
                break;
            }
        }
        // 求出左右子树中节点的个数
        int leftSize = mid - l2;
        root.left = build(l1 + 1,l1 + leftSize,l2,mid - 1);
        root.right = build(l1 + leftSize + 1,r1,mid + 1,r2);
        return root;

    }
}
```
## 剑指 Offer 09. 用两个栈实现队列
> 原题链接：[剑指 Offer 09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

首先开辟两个栈，一个栈用来放入元素，另一个栈用来弹出元素。
```java
class CQueue {
    private LinkedList<Integer> stackPop;
    private LinkedList<Integer> stackPush;
    public CQueue() {
        stackPop = new LinkedList<>();
        stackPush = new LinkedList<>();
    }
    
    public void appendTail(int value) {
        stackPush.add(value);
    }
    public int deleteHead() {
        if(!stackPop.isEmpty()) return stackPop.removeLast();
        if(stackPush.isEmpty()) return -1;
        while(!stackPush.isEmpty()) {
            stackPop.addLast(stackPush.removeLast());
        }
        return stackPop.removeLast();
    }
}
```
## 剑指 Offer 10- I. 斐波那契数列
这个题我首先是通过递归来做的，然后直接超时了，然后采用动态规划的解法。

- `f[0] = 0 ; f[1] = 1`
- `f[n] = f[n - 1] + f[n - 2]`

但是我们发现，当前位置的计算只依赖于前两个连续的位置，所以我们可以通过开变量的方式来替换通过数组进行计算。如果说我们将三个连续的数依次标记为`p、q、res`
时间复杂度：`O(n)`
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1658756306306-57a9531d-19c9-4291-9570-59ab2324da35.png)
数组：`0		1	1	2	3	5`
项：    `0		1	2	3	4	5`

```java
class Solution {
    private int MOD = 1000000007;
    public int fib(int n) {
        if(n <= 1) return n;
        int p = 0;
        int q = 1;
        int res = 0;
        for(int i = 2; i <= n; i++) {
            res = (p + q) % MOD;
            p = q;
            q = res;
        }
        return res; 
    }
}
```
## 剑指 Offer 10- II. 青蛙跳台阶问题
与上题同解
```java
class Solution {
    private int MOD = 1000000007;
    public int numWays(int n) {
        int p,q,r;
        p = q = r = 1;
       for(int i = 2; i <= n; i++) {
           r = (p + q) % MOD;
           p = q;
           q = r;
       }
       return r;
    }
}
```
## 剑指 Offer 11. 旋转数组的最小数字
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1658757190539-a942e02e-c500-4192-8840-0a68fb14a03b.png)
我们发现除了后半段中水平的一段，其余部分满足二分的条件（二段性），我们的分界点就是答案。所以，我们需要将后半段中水平的部分进行删除。删除之后：

- 前半段都是`>= nums[0]`
- 后半段都是`< nums[0]`

这里给出两个方案。分别对应二分的两个模板
时间复杂度：`O(logn)`
```java
// 二分出后半段的第一个元素
class Solution {
    public int minArray(int[] numbers) {
        int l = 0;
        int r = numbers.length - 1;
        while(l < r && numbers[0] == numbers[r]) r--;
        if(numbers[r] >= numbers[0]) return numbers[0];
        while(l < r) {
            int mid = l + r >> 1;
            if(numbers[mid] < numbers[0]) {
                r = mid;
            }else {
                l = mid + 1;
            }
        }
        return numbers[l];
    }
}

// 二分出前半段的最后一个元素
class Solution {
    public int minArray(int[] numbers) {
        int l = 0;
        int r = numbers.length - 1;
        while(r > 0 && numbers[0] == numbers[r]) r--;
        if(numbers[r] >= numbers[0]) return numbers[0];
        while(l < r) {
            int mid = l + r + 1 >> 1;
            if(numbers[mid] >= numbers[0]) {
                l = mid;
            }else {
                r = mid - 1;
            }
        }
        return numbers[l+1];
    }
}
```
## 剑指 Offer 12. 矩阵中的路径
让每个点都作为起点进行一次dfs，
时间复杂度：`O()`
```java
class Solution {
    private boolean[][] st;
    private int[] dx = {0,1,0,-1};
    private int[] dy = {1,0,-1,0};
    public boolean exist(char[][] board, String word) {
        st = new boolean[board.length][board[0].length];
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[i].length; j++) {
                if(dfs(board,word,0,i,j)) return true;
            }
        }
        return false;
    }
    public boolean dfs(char[][] board,String word,int u,int x,int y) {
        if(board[x][y] != word.charAt(u)) return false;
        if(u == word.length() - 1) return true;
        st[x][y] = true;
        for(int i = 0; i < 4; i++) {
            int a = x + dx[i];
            int b = y + dy[i];
            if(a < 0 || a >= board.length || b < 0 || b >= board[a].length) continue;
            if(st[a][b]) continue;
            if(dfs(board,word,u + 1,a,b)) return true;
        }
        st[x][y] = false;
        return false;
    }
}
```
## 剑指 Offer 13. 机器人的运动范围
BFS的典型应用。每次都会拓展自己能到的节点。相当于BFS的模板题吧
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1658757918787-6873a8e3-8fef-4684-b523-aa10e465f40f.png)

```java
class Solution {
    private static class Node{
        int x;
        int y;
        Node(int x,int y) {
            this.x = x;
            this.y = y;
        }
    }
    private boolean[][] st;
    private int[] dx = {0,1,0,-1};
    private int[] dy = {1,0,-1,0};
    private int get(int a,int b) {
        int res = 0;
        while(a != 0) {
            res += a % 10;
            a /= 10;
        }
         while(b != 0) {
            res += b % 10;
            b /= 10;
        }
        return res;

    }
    public int movingCount(int m, int n, int k) {
        this.st = new boolean[m][n];
        LinkedList<Node> q = new LinkedList<>();
        st[0][0] = true;
        q.add(new Node(0,0));
        int res  = 0;
        while(!q.isEmpty()) {
            Node node = q.removeFirst();
            res++;
            for(int i = 0; i < 4; i++) {
                int a = node.x + dx[i];
                int b = node.y + dy[i];
                if(a >= m || a < 0 || b >= n || b < 0) continue;
                if(st[a][b]) continue;
                if(get(a,b) > k) continue;
                q.add(new Node(a,b));   
                st[a][b] = true;           
            }
            
        }
        return res;

    }
}
```
## 剑指 Offer 14 - I. 剪绳子
> 原题链接：[剑指 Offer 14- I. 剪绳子](https://leetcode.cn/problems/jian-sheng-zi-lcof/)

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661777859407-e216e5f6-afb4-4a21-9f4a-a336506be67b.png)
数学问题

```java
class Solution {
    public int cuttingRope(int n) {
        if(n <= 3) return 1 * (n - 1);
        int res = 1;

        if(n % 3 == 1) {
            res = 4;
            n -= 4;
        }
        if(n % 3 == 2) {
            res = 2;
            n -= 2;
        }
        while(n != 0) {
             res *= 3;
             n -= 3;
        }
        return res;

    }
}
```
## 剑指 Offer 14- II. 剪绳子 II
我当时还在想，为什么和上一题一样，直接把上题代码粘贴过来，过来直接进行数据溢出了。哈哈哈，转为`long`就过了
```java
class Solution {
    public int cuttingRope(int n) {
        if(n <= 3) return 1 * (n - 1);
        long res = 1;

        if(n % 3 == 1) {
            res = 4;
            n -= 4;
        }
        if(n % 3 == 2) {
            res = 2;
            n -= 2;
        }
        while(n != 0) {
             res = res *  3 % 1000000007;
             n -= 3;
        }
        return (int)res % 1000000007;

    }
}
```
## 剑指 Offer 15. 二进制中1的个数

> [剑指 Offer 15. 二进制中1的个数](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

循环扫描
```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res = 0;
        for(int i = 0; i < 32; i++) {
            if(((n >> i & 1)) == 1) res++;
        }
        return res;     
    }
}
```
## 剑指 Offer 16. 数值的整数次方

> [剑指 Offer 16. 数值的整数次方](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

快速幂模板题。
比如说：`35`----对5进行拆分成二进制`101`
```java
class Solution {
    private double get(double a,long b) {
        double res = 1;
        while(b != 0) {
            if((b & 1) != 0) res = res * a;
            b = b >> 1;
            a *= a;
        }
        return res;
    }
    public double myPow(double a, int n) {
        double res = get(a,Math.abs((long)n));
        if(n < 0){
            return 1 / res;
        }
        return res;
    }
}
```
## 剑指 Offer 17. 打印从1到最大的n位数

> [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

模拟题
```java
class Solution {
    public int[] printNumbers(int n) {
        int end = 1;
        while(n > 0) {
            end *= 10;
            n--;
        }
        end--;// 相当于从 1000 --- 999
        int[] res = new int[end];
        for(int i = 0; i < end; i++) res[i] = i + 1;
        return res;

    }
}
```
## 剑指 Offer 18. 删除链表的节点

> [剑指 Offer 18. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

对于这种头节点有删除可能的，我们通过设置一个虚拟头节点进行解决
```java
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode vir = new ListNode(-1,head);
        ListNode cur = vir.next;
        ListNode pre = vir;
        while(cur != null) {
            if(cur.val == val) {
                pre.next = cur.next;
            }
            pre = pre.next;
            cur = cur.next;
        }
        return vir.next;
    }
}
```
## 剑指 Offer 19. 正则表达式匹配

> [剑指 Offer 19. 正则表达式匹配](https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int n = s.length();
        int m = p.length();
        s = " " + s;
        p = " " + p;
        char[] arrS = s.toCharArray();
        char[] arrP = p.toCharArray();
        boolean[][] f = new boolean[n+10][m+10];
        f[0][0] = true;
        for(int i = 0 ; i <= n; i++){
            for(int j = 1; j <= m;j++){
                if(j+1 <= m && arrP[j+1] == '*') continue;
                if(arrP[j] != '*'){
                    boolean flag = (arrP[j] == arrS[i] || (arrP[j] == '.'));
                    f[i][j] = i != 0 && f[i-1][j-1] && flag;
                }else{
                    boolean flag = (arrP[j-1] == arrS[i] || (arrP[j-1] == '.'));
                    f[i][j] = f[i][j-2] || (i!=0 && f[i-1][j] && flag);
                }
            }
        }
        return f[n][m];

    }
}
```
## 剑指 Offer 20. 表示数值的字符串

> [剑指 Offer 20. 表示数值的字符串](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

```java
class Solution {
    public boolean isNumber(String s) {
        if(s == null || s.length() == 0) return false;

        char[] arr = s.trim().toCharArray();
        int n = arr.length;
        if(n == 0 || (arr[0] == '.' && n == 1)) return false;

        boolean point = false;
        boolean e = false;
        boolean num = false;
        for(int i = 0; i < n; i++) {
            if(arr[i] >= '0' && arr[i] <= '9') {
                num = true;
            }else if(arr[i] == '.') {
                // 如果说前面出现过 . 或者前面出现过 e 返回false
                if(point || e ) return false;
                point = true;
            }else if(arr[i] == 'e' || arr[i] == 'E') {
               if(e || !num) {
                   return false;
               }
               e = true;
               num = false;

            } else if(arr[i] == '-' || arr[i] == '+') {
                
                if(i!=0 && arr[i - 1] != 'e' && arr[i - 1] != 'E') return false;
                
            } else {
                return false;
            }
        }
        return num;
    }
}
```
# [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)
双指针愉快通过
```java
class Solution {
    public int[] exchange(int[] nums) {
        if(nums == null || nums.length == 0) return nums;
        int r = nums.length;
        int l = -1;
        while(l < r) {
            do{l++;}while(l < r && nums[l] % 2 != 0);
            do{r--;} while(l < r && nums[r] % 2 == 0);
            if(l < r) {
                int t = nums[l];
                nums[l] = nums[r];
                nums[r] = t;
            }
        }
        return nums;
    }
}
```
# [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode pre = head;
        ListNode cur = head;
        for(int i = 0; i < k; i++) cur = cur.next;
        while(cur != null) {
            cur = cur.next;
            pre = pre.next;
        }
        return pre;

    }
}
```
# 剑指 Offer 24. 反转链表
> 原题链接：[剑指 Offer 24. 反转链表](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;

    }
}
```
```java
class Solution {
    public ListNode reverse(ListNode pre,ListNode cur) {
        if(cur == null) return pre;
        ListNode tem = cur.next;
        cur.next = pre;
        pre = cur;
        return reverse(pre,tem);
    }
    public ListNode reverseList(ListNode head) {
        return reverse(null,head);

    }
}
```
# 剑指 Offer 25.合并两个排序的链表
> 原题链接：[剑指 Offer 25. 合并两个排序的链表](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
        if(l2 == null) return l1;
        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next,l2);
            return l1;
        }else {
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
    }
}
```
# 剑指 Offer 26. 树的子结构
> 原题链接：[剑指 Offer 26. 树的子结构](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

```java
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(A == null || B == null) return false;
        if(isSubTree(A,B)) {
            return true;
        }
        return isSubStructure(A.left,B) || isSubStructure(A.right,B);
    }
    private boolean isSubTree(TreeNode A,TreeNode B) {
        if(B == null) return true;
        if(A == null) return false;
        if(A.val != B.val) return false;
        return isSubTree(A.left,B.left) && isSubTree(A.right,B.right);
    }
}
```
# 剑指 Offer 27.二叉树的镜像
> 原题链接：[剑指 Offer 27. 二叉树的镜像](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/)

```java
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return null;
        TreeNode node = root.left;
        root.left = root.right;
        root.right = node;
        if(root.left != null) mirrorTree(root.left);
        if(root.right != null) mirrorTree(root.right);
        return root;

    }
}
```
# [剑指 Offer 28. 对称的二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)
对于一个对称二叉树，应该满足以下条件

1. 空树是一个对称树
2. 如果说一个树不是空树，递归判断两个子树是否是对称的
- 左子树 和 右子树 都是空，这个树是对称树
- 左子树 和  右子树 的节点值一样，并且左子树的左子树 与 右子树的右子树对称，左子树的右子树与右子树的左子树对称
```java
class Solution {
    private boolean dfs(TreeNode l,TreeNode r) {
        if(l == null && r == null) return true;
        if(l == null || r == null) return false;
        if(l.val != r.val) return false;
        return dfs(l.left,r.right) && dfs(l.right,r.left);
    }
    public boolean isSymmetric(TreeNode root) {
        return dfs(root,root); 

    }
}
```
# [剑指 Offer 29. 顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)
```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        int n = matrix.length;
        if(n == 0) return new int[]{};
        int m = matrix[0].length;
        int[] res = new int[n * m];
        boolean[][] st = new boolean[n][m];
        int[] dx = {0,1,0,-1};
        int[] dy = {1,0,-1,0};
        int index = 0;
        int x,y,d;
        x = y = d =  0;
        for(int i = 0; i < n * m; i++) {
            res[i] = matrix[x][y];
            st[x][y] = true;
            int a = x + dx[d];
            int b = y + dy[d];
            if(a >= n || a < 0 || b >= m || b < 0 || st[a][b]) {
                d  = (d + 1) % 4;
                a = x + dx[d];
                b = y + dy[d];
            }
            x = a;
            y = b;
        }
        return res;

    }
}
```
# 剑指Offer30. 包含min函数的栈
> 原题链接：[剑指 Offer 30. 包含min函数的栈](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)

借助于一个辅助栈，而这个辅助栈就是单调栈
```java
class MinStack {
    private LinkedList<Integer> stack;
    private LinkedList<Integer> min;

    /** initialize your data structure here. */
    public MinStack() {
        stack = new LinkedList<>();
        min = new LinkedList<>();

    }
    
    public void push(int x) {
        stack.add(x);
        if(min.isEmpty() || min.getLast() >= x) min.add(x);
    }
    
    public void pop() {
        int x = stack.removeLast();
        if(x == min.getLast()) min.removeLast();
    }
    
    public int top() {
        return stack.getLast();
    }
    
    public int min() {
        return min.getLast();
    }
}
```
# 剑指Offer 31. 栈的压入、弹出序列
> 原题链接：[剑指 Offer 31. 栈的压入、弹出序列](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

一个栈无非就是两种操作，压入一个元素，弹出栈顶元素。可以开一个辅助栈进行模拟一下，最后判断一下这个辅助栈是否是空即可。
```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        if(pushed == null && popped == null) return true;
        int n = pushed.length;
        int m = pushed.length;
        if(n != m) return false;
        int[] stack = new int[n + 1];
        int tt = 0;
        int index = 0;
        for(int x : pushed) {
            stack[++tt] = x;
            while(tt != 0 && stack[tt] == popped[index]) {
                index++;
                tt--;
            }
        }
        return tt == 0;
    }
}
```
# 剑指Offer 32 - I. 从上到下打印二叉树
> 原题链接：[剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

BFS模板题
```java
class Solution {
    public int[] levelOrder(TreeNode root) {
        if(root == null) return new int[]{};
        LinkedList<TreeNode> path = new LinkedList<>();
        List<Integer> res = new ArrayList<>();
        path.add(root);
        while(!path.isEmpty()) {
            TreeNode node = path.removeFirst();
            res.add(node.val);
            if(node.left != null) path.add(node.left);
            if(node.right != null) path.add(node.right);
        }
        int[] ans = new int[res.size()];
        for(int i= 0; i < res.size();i++) {
            ans[i] = res.get(i);
        }
        return ans;
        

    }
}
```

# 剑指 Offer 32 - II. 从上到下打印二叉树 II
> 原题链接：[剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        LinkedList<TreeNode> path = new LinkedList<>();
        path.add(root);
        while(!path.isEmpty()) {
            List<Integer> floor = new ArrayList<>();
            int n = path.size();
            for(int i = 0; i < n; i++) {
                floor.add(path.get(i).val);
            }
            for(int i = 0; i < n; i++) {
                TreeNode node = path.removeFirst();
                if(node.left != null) path.add(node.left);
                if(node.right != null) path.add(node.right);
            }            
            res.add(floor);
        }
        return res;

    }
}
```
# 剑指 Offer 32 - III. 从上到下打印二叉树 III
> 原题链接：[剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        LinkedList<TreeNode> path = new LinkedList<>();
        if(root == null) return res;
        path.add(root);
        int flag = 1;
        while(!path.isEmpty()) {
            List<Integer> floor = new ArrayList<>();
            int n = path.size();
            if(flag > 0) {
                for(int i = 0; i < n; i++) floor.add(path.get(i).val);     
            } else {
                for(int i = n - 1; i >= 0; i--) floor.add(path.get(i).val); 
            }
            for(int i = 0; i < n; i++) {
                TreeNode node = path.removeFirst();
                if(node.left != null) {
                    path.add(node.left);
                }
                if(node.right != null) {
                    path.add(node.right);
                }
            }
            flag *= -1;
            res.add(floor);
        }
        return res;
    }
}
```
# 剑指 Offer 33. 二叉搜索树的后序遍历序列
> 原题链接：[剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

递归的问题，我们只需要去考虑一层即可。后序遍历的顺序为：`左 -- 右 -- 根`。
我们使用两个变量`l`和`r`分别指向这颗树后序遍历序列的起始位置和终止位置。在这个序列中，最后一个位置是`r`，也就是根所在的位置。
对于一颗二叉搜索树，左子树的节点都是小于根节点的，右子树的节点都是大于根节点的，而左子树的根，就是这个序列中最后一个小于根节点的位置，通过这个特点，我们就可以很容易找到位置，这里我们标记这个位置为`k`，在`[k,r-1]`，这一段就是这颗树的右子树，只要这个区间中的数都是大于或者等于根节点的，就说明这一点为根能构成二叉搜索树。
```java
class Solution {
    private int n;
    private int[] f;
    public boolean verifyPostorder(int[] f) {
        this.n = f.length;
        this.f = f;
        return dfs(0,n - 1);
    }
    private boolean dfs(int l,int r) {
        if(l >= r) return true;
        int root = f[r];
        int k = l;
        while(k < r && f[k] < root) k++;
        for(int i = k; i < r; i++) {
            if(f[i] < root) return false;
        }
        return dfs(l, k - 1) && dfs(k,r - 1);

    }
     
}
```
# 剑指 Offer 34. 二叉树中和为某一值的路径
> 原题链接：[剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    int sum = 0;
    int target = 0;
    private void dfs(TreeNode node) {
        if(node == null) return;
        sum += node.val;
        path.add(node.val);
        if(sum == target && node.left == null && node.right == null) {
            res.add(new LinkedList<>(path));
        }
        dfs(node.left);
        dfs(node.right);
        sum -= node.val;
        path.removeLast();

    }
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        if(root == null) return res;
        this.target = target;
        dfs(root);
        return res;

    }
}
```
# 剑指 Offer 35. 复杂链表的复制
> 原题链接：[剑指 Offer 35. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1659279496151-36e58fbb-0c29-437f-a835-06e9c2904cff.png#clientId=u112e4809-c346-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=380&id=u118acb7e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=485&originWidth=1075&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45933&status=done&style=none&taskId=u3134c1c5-9e37-41e9-a9bd-d58702a8c6e&title=&width=843.1372706682031)
第一次要进行断开，第二次要进行重连
```java
class Solution {
    public Node copyRandomList(Node head) {
        for(Node p = head; p != null; p = p.next.next) {
            Node tem = new Node(p.val);
            tem.next = p.next;
            p.next = tem;
        }

        for(Node p = head; p != null;p = p.next.next) {
            if(p.random == null) continue;
            p.next.random = p.random.next;
        }
        Node res = new Node(-1);
        Node cur = res;
        for(Node p = head; p !=null; p = p.next) {      
            cur = cur.next = p.next;
            p.next = p.next.next;
        }    
        return res.next;
        
    }
}
```
# 剑指 Offer 36. 二叉搜索树与双向链表
> 原题链接：[剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

将所有点放在集合之中
```java
class Solution {
    // 将所有的节点放入到集合中
    private LinkedList<Node> path = new LinkedList<>();
    private void dfs(Node root) {
        if(root == null) return;
        dfs(root.left);
        path.add(root);
        dfs(root.right);
    }
    public Node treeToDoublyList(Node root) {
        if(root == null) return null;
        dfs(root);
        Node head = path.removeFirst();
        Node cur = head;
        while(!path.isEmpty()) {
            Node node = path.removeFirst();
            cur.right = node;
            node.left = cur;
            cur = node;
        }
        // 将尾节点和头节点连接起来
        cur.right = head;
        head.left = cur;
        
        return head;      
    }
}
```
# 剑指 Offer 37. 序列化二叉树
> 原题链接：[剑指 Offer 37. 序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/)

# 剑指 Offer 38. 字符串的排列
> 原题链接：[剑指 Offer 38. 字符串的排列](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/)

```java
class Solution {
    private int n;
    private String s;
    private List<String> res;
    private StringBuffer path = new StringBuffer();
    private boolean[] st;
    private Map<String,Integer> map = new HashMap<>();
    public String[] permutation(String s) {      
        this.n = s.length();
        this.s = s;
        this.res = new ArrayList<>();
        this.st = new boolean[n + 1];
        dfs(0);
        String[] ans = new String[res.size()];
        for(int i = 0; i < res.size(); i++) ans[i] = res.get(i);
        return ans;
    }
    private void dfs(int u) {
        if(u == n) {
            if(map.containsKey(path.toString())) return;
            map.put(path.toString(),1);
            res.add(path.toString());
            return;
        }
        for(int i = 0; i < n; i++) {
            if(!st[i]) {
                path.append(s.charAt(i));
                st[i] = true;
                dfs(u+1);
                st[i] = false;
                path.deleteCharAt(path.length() - 1);
            }
        }
    }
}
```
# 剑指 Offer 39. 数组中出现次数超过一半的数字
> 原题链接：[剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

方式一：使用HashMap
```java
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer,Integer> map = new HashMap<>();
        int n = nums.length;
        for(int i = 0; i < n; i++) {
            Integer value = 1;
            if(map.containsKey(nums[i])) {
                value = map.get(nums[i]);
                value++;
            }
            if(value > (n / 2)) return nums[i];
            map.put(nums[i],value);
        }
        return -1;
    }
}
```
 val 是 认为当前数为 我们想要的那个答案 count 为val 计数器 
 在遍历的过程当中 count 如果变为0 或者小于 0 那么就一定不是我们想要的那个答案 因为 我们想要的答案的count值 到 最后 是 一定不会等于小于 0 的
```java
class Solution {
    public int majorityElement(int[] nums) {
        int n = nums.length;
        int cnt = 0;
        int val = -1;
        for(int x : nums) {
            if(x == val) {
                cnt++;
            } else {
                if(cnt != 0) {
                    cnt--;
                } else {
                    cnt = 1;
                    val = x;
                }
            }
        }
        return val;


    }
}
```
# 剑指 Offer 40. 最小的k个数
> 原题链接：[剑指 Offer 40. 最小的k个数](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

将所有元素都添加到堆里面，返回前k个元素即可
```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        int n = arr.length;
        for(int i = 0; i < n; i++) {
            queue.add(arr[i]);
        }
        int[] res = new int[k];
        int index = 0;
        while(k-- > 0 && !queue.isEmpty()) {
            res[index++] = queue.poll();
        }
        return res;
    }
}
```
# [剑指 Offer 41. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)
![33055_ce5d080229-剑指Offer-41.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1660483201870-62dffb75-55fe-4e28-8ea3-ce76febd7704.png#clientId=ua0634bee-2784-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u2cf7fd86&margin=%5Bobject%20Object%5D&name=33055_ce5d080229-%E5%89%91%E6%8C%87Offer-41.png&originHeight=720&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25672&status=done&style=none&taskId=ucc126edc-db80-41c7-82ca-e086290dad0&title=)
```java
class MedianFinder {
    private PriorityQueue<Integer> min = new PriorityQueue<>();
    private PriorityQueue<Integer> max = new PriorityQueue<>((x,y) -> (y - x));//大根堆
    /** initialize your data structure here. */
    public MedianFinder() {

    }
    
    public void addNum(int num) {
        //如果是偶数
        if(min.size() == max.size()) {
            min.add(num);
            max.add(min.poll());
        } else {
            max.add(num);
            min.add(max.poll());
        }

    }
    
    public double findMedian() {
        //如果是偶数
        if(min.size() == max.size()) {
            return (min.peek() + max.peek()) / 2.0;
        } else {
            return max.peek() * 1.0;
        }
    }
}
```
# [剑指 Offer 42. 连续子数组的最大和](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        if(n == 0) return 0;
        int[] f = new int[n + 10];
        f[0] = nums[0];
        int res = f[0];
        for(int i = 1; i < n; i++) {
            f[i] = nums[i];
            if(f[i] < nums[i] + f[i-1]) {
                f[i] = nums[i] + f[i-1];
            }
            res = Math.max(res,f[i]);
        }
        return res;

    }
}
```
# [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)
```java
class Solution {
    public int countDigitOne(int n) {
        long bit = 1;
        long sum = 0;
        while(bit <= n) {
            long cur = (n / bit) % 10;
            long low = n % bit;
            long height = n / bit / 10;

            if(cur > 1) {
                sum += (height + 1) * bit;
            }else if(cur == 1) {
                sum += (height * bit) + (1 + low);
            }else {
                sum += height * bit;
            }
            bit *= 10;
        }
        return (int)sum;

    }
}
```
# [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)
```java
class Solution {
    public int findNthDigit(int n) {
        if(n == 0) return 0;
        long base = 1;
        long i = 1;
        long s = 9;
        while(n > i * s) {
            n -= i * s;
            i++;
            s *= 10;
            base *= 10;
        }
        long  num = base + (n + i - 1) / i - 1;
        long r = n % i == 0 ? i : n % i;

        //取出num的第r位，去掉后面的i - r位即可
        //如12345的第三位，后面还有两位45，我们将这两位去掉才好取出顺数的第三位
        for(int j = 1; j <= i - r;j++){
            num /= 10;
        }
        return (int)(num % 10);

    }
}
```
# [剑指 Offer 45. 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)
```java
class Solution {
    public String minNumber(int[] nums) {
        List<Integer> res = new ArrayList<>();
        int n = nums.length;
        for(int i = 0; i < n; i++) {
            res.add(nums[i]);
        }
        Collections.sort(res,new Comparator<Integer> (){
            @Override
            public int compare(Integer o1, Integer o2){
               String s1 = o1+""+o2;
               String s2 = o2+""+o1;
               return s1.compareTo(s2);
            }
        });
        StringBuilder sb = new StringBuilder();
        res.forEach(s -> {
            sb.append(s);
        });
        return sb.toString();

    }
}
```
# [剑指 Offer 46. 把数字翻译成字符串](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)
```java
class Solution {
    public int translateNum(int num) {
        String s = num + "";
        int[] f = new int[s.length() + 10];
        f[0] = 1;
        for(int i = 1; i <= s.length(); i++) {
            f[i] = f[i - 1];
            if(i > 1) {
                int t = (s.charAt(i - 2) - '0') * 10 + (s.charAt(i -  1)- '0');
                if(t >= 10 && t <= 25) {
                    f[i] += f[i-2];
                }
            }
        
        }
        return f[s.length()];

    }
}
```
# [剑指 Offer 47. 礼物的最大价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/)
```java
class Solution {
    public int maxValue(int[][] grid) {
        int[][] f = new int[grid.length][grid[0].length];
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[i].length;j++) {
                f[i][j] = grid[i][j];
                if(i > 0) {
                    f[i][j] = Math.max(f[i][j],f[i-1][j] + grid[i][j]);
                }
                if(j > 0) {
                    f[i][j] = Math.max(f[i][j],f[i][j-1] + grid[i][j]);
                }
            }
        }
        return f[grid.length - 1][grid[0].length - 1];

    }
}
```
# [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character,Integer> map = new HashMap<>();
        int left = 0;
        int res = 0;
        for(int right = 0; right < s.length(); right++) {
            if(map.containsKey(s.charAt(right))) {
                left = Math.max(left,map.get(s.charAt(right)) + 1);
            } 
            map.put(s.charAt(right),right);
            res = Math.max(res,right - left + 1);
        }
        return res;

    }
}
```
# [剑指 Offer 49. 丑数](https://leetcode.cn/problems/chou-shu-lcof/)
```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] res = new int[n];
        int i,j,k;
        i = j = k = 0;
        res[0] = 1;
        for(int u = 1; u < n; u++) {
            int t = Math.min(res[i] * 2,Math.min(res[j] * 3,res[k] * 5));
            res[u] = t; 
            if(t == res[i] * 2) i++;
            if(t == res[j] * 3) j++;
            if(t == res[k] * 5) k++;
        }
        return res[n - 1];

    }
}
```
# [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)
```java
class Solution {
    public char firstUniqChar(String s) {
        int[] st = new int[26];
        for(int i = 0; i < s.length(); i++) {
            st[s.charAt(i) - 'a']++;
        }
        for(int i = 0; i < s.length(); i++) {
            if(st[s.charAt(i) - 'a'] == 1) return s.charAt(i);
        }
        return ' ';
    }
}
```
# 剑指Offer 51.数组中的逆序对
> 原题链接：[剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

```java
class Solution {
    private int[] tem;
    public int merget_sort(int[] nums,int l,int r) {
        if(l >= r) return 0;
        int mid = l + r >> 1;
        int res = merget_sort(nums,l,mid) + merget_sort(nums,mid + 1,r);
        int k = 0;
        int i = l;
        int j = mid + 1;
        while(i <= mid && j <= r) {
            if(nums[i] <= nums[j]) {
                tem[k++] = nums[i++];
            } else {
                tem[k++] = nums[j++];
                res += mid - i + 1;
            }
        }
        while(i <= mid) tem[k++] = nums[i++];
        while(j <= r) tem[k++] = nums[j++];
        for(i = l,j = 0; i <= r; i++,j++) {
            nums[i] = tem[j];
        }
        return res;
    }
    public int reversePairs(int[] nums) {
        tem = new int[nums.length];
        return merget_sort(nums,0,nums.length - 1);

    }
}
```
# [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)
```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode temA = headA;
        ListNode temB = headB;
        while(temA != temB) {
            if(temA == null && temB == null) return null;
            temA = temA == null ? headB : temA.next;
            temB = temB == null ? headA : temB.next;
        }
        return temA;       
    }
}
```
# [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)
```java
class Solution {
    private List<Integer> list;
    public void dfs(TreeNode node) {
        if(node == null) {
            return;
        }
        dfs(node.right);
        list.add(node.val);
        dfs(node.left);
    }
    public int kthLargest(TreeNode root, int k) {
        list = new ArrayList<>();
        dfs(root);
        return list.size() < k ? -1 : list.get(k - 1);

    }
}
```
# [剑指 Offer 55 - I. 二叉树的深度](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/)
```java
class Solution {
    public int dfs(TreeNode node) {
        if(node == null) {
            return 0;
        }
        int res = 1;
        int left = 0;
        int right = 0;
        if(node.left != null) {
            left = dfs(node.left);
        }
        if(node.right != null) {
           right = dfs(node.right);
        }
        return res += Math.max(left,right);
    }
    public int maxDepth(TreeNode root) {
        return dfs(root);
    }
}
```
# [剑指 Offer 55 - II. 平衡二叉树](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private boolean ans;
    public int dfs(TreeNode node) {
        if(node == null) return 0;
        int left = 0;
        int right = 0;
        if(node.left != null) {
            left = dfs(node.left);
        }
        if(node.right != null) {
            right = dfs(node.right);
        }
        if(Math.abs(right - left) > 1) ans = false;
        return Math.max(left,right) + 1;
        
    }
    public boolean isBalanced(TreeNode root) {
        ans = true;
        dfs(root);
        return ans;
    }
}
```
# [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)
```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        // 两个数相同异或值为 0 ,不同为1
        int f = 0;
        for(int x : nums) f ^= x;
        int[] ans = new int[2];
        int k = 0;
        while((f >> k & 1) == 0) k++;
        int first = 0;
        for(int x : nums) {
            if((x >> k & 1) == 1) {
                first ^= x;
            }
        }
        ans[0] = first;
        ans[1] = first ^ f;
        return ans;

    }
}
```
# [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22570918/1661485059140-a501e423-7087-4021-b2f6-7d4152cfcde9.png#clientId=ue413fa1b-c4c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1d146d25&margin=%5Bobject%20Object%5D&name=image.png&originHeight=894&originWidth=1192&originalType=url&ratio=1&rotation=0&showTitle=false&size=73195&status=done&style=none&taskId=u143975b8-260f-401d-9d11-b388b5626f7&title=)
实际上，只需要修改求余数值 m ，即可实现解决 **除了一个数字以外，其余数字都出现 _m_ 次** 的通用问题

- 通过 & 运算可以拿出目标数组的指定位
```java
class Solution {
    public int singleNumber(int[] nums) {
        int[] count = new int[32];
        for(int i = 0; i < nums.length; i++) {
            for(int j = 0; j < 32; j++) {
                count[j] += nums[i] & 1;
                nums[i] >>= 1;
            }
        }
        int res = 0;
        int m = 3;
        for(int i = 0; i < 32; i++) {
            // 左移一位
            res <<= 1;
            // 恢复第i位上的数值
            res |= count[31 - i] % m;

        }
        return res;
    }
}
```
# [剑指 Offer 57. 和为s的两个数字](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/)
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] ans = {-1,-1};
        int n = nums.length;
        Set<Integer> set = new HashSet<>();
        for(int i = 0; i < n; i++) {
            int t  = target - nums[i];
            if(set.contains(t)) {
                return new int[]{t,nums[i]};
            }
            set.add(nums[i]);
        }
        return ans;
    }
}
```
# [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)
```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int l = 1;
        int r = 2;
        int s = 3;
        List<int[]> res = new ArrayList<>();
        while(l < r) {
            if(s == target) {
                int[] tem = new int[r - l + 1];
                for(int i = l; i <= r; i++) {
                    tem[i - l] = i;
                }
                res.add(tem);
                
            } 
            if(s >= target) {
                s -= l;
                l++;
            } else  {
                r++;
                s += r;
            }
        }
        return res.toArray(new int[0][]);
    }
}
```
# [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/)
```java
class Solution {
    public String reverseWords(String s) {
        if(s == null) return "";
        s = s.trim();
        String[] arr = s.split(" ");
        System.out.println();
        StringBuilder ans = new StringBuilder();
        for(int i = arr.length - 1; i >= 0; i--) {
            if(arr[i].equals("")) continue;
            ans.append(arr[i]).append(" ");
        }
        return ans.toString().trim();

    }
}
```
# [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)
```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        if(s == null || s.length() == 0) return "";
        if(s.length() < n) return s;
        StringBuilder ans = new StringBuilder();
        ans.append(s.substring(n,s.length()));
        ans.append(s.substring(0,n));
        return ans.toString();
    }
}
```
# [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)
```java
class Solution {
    public int[] maxSlidingWindow(int[] arr, int k) {
        if(arr.length == 0) return new int[]{};
        int n = arr.length;
        int[] q = new int[n + 10];
        int hh = 0;
        int tt = -1;
        List<Integer> ans = new ArrayList<>();
        int index  = 0;
        for(int i = 0; i < n;i++) {
            if(hh <= tt && i - k + 1 > q[hh]) hh++;  
            while(hh <= tt && arr[q[tt]] <= arr[i]) tt--;
                q[++tt] = i;
                if(i  >= k - 1) ans.add(arr[q[hh]]);
            
        }
        int size = ans.size();
        int[] res = new int[size];
        for(int i = 0; i < size; i++) {
            res[i] = ans.get(i);
        }
        return res;

    }
}
```

# [剑指 Offer 61. 扑克牌中的顺子](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

1. 删0：去除大小王
2. 判重：有重复元素就不是顺子
3. 判断最大值和最小值之间是否是小于四的
```java
class Solution {
    public boolean isStraight(int[] nums) {
        if(nums == null || nums.length == 0) return false;
        Arrays.sort(nums);
        int k = 0;
        while(nums[k] == 0) k++;
        for(int i = k; i < nums.length - 1; i++) {
            if(nums[i] == nums[i + 1]) return false;
        }
        return nums[nums.length - 1] - nums[k] <= 4;
    }
}
```
# [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)
```java
class Solution {
    public int lastRemaining(int n, int m) {
        int x = 0;
       for(int i = 2; i <= n; i++) {
           x = (x + m) % i;
       }
       return x;
    }
}
```
# [剑指 Offer 63. 股票的最大利润](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/)
```java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        int min = 0x3f3f3f;
        int n = prices.length;
        for(int i = 0; i < n; i++) {
            res = Math.max(res,prices[i] - min);
            min = Math.min(min,prices[i]);
        }
        return res;
    }
}
```
# [剑指 Offer 64. 求1+2+…+n](https://leetcode.cn/problems/qiu-12n-lcof/)
```java
class Solution {
    public int sumNums(int n) {
        int res = n;
        boolean falg = (n > 0) && ((res += sumNums(n - 1)) > 0);
        return res;
    }
}
```

# [剑指 Offer 65. 不用加减乘除做加法](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)
```java
class Solution {
    public int add(int a, int b) {
        if(a == 0) return b;
        if(b == 0) return a;
        int c = a ^ b;
        int d = (a & b) << 1;
        return add(c,d);
    }
}
```

# [剑指 Offer 66. 构建乘积数组](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/)
```java
class Solution {
    public int[] constructArr(int[] a) {
        int n = a.length;
        int[] res = new int[n];
        int p = 1;
        for(int i = 0; i < n;i++) {
            res[i] = p;
            p *= a[i]; 
        }
        p = 1;
        for(int i = n - 1; i >= 0;i--) {
            res[i] *= p;
            p *= a[i];
        }
        return res;
    }
}
```
# [剑指 Offer 67. 把字符串转换成整数](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)
```java
class Solution {
    public int strToInt(String str) {
        if(str == null || str.length() == 0) return 0;
        int k = 0;
        while(k < str.length() && str.charAt(k) == ' ') k++;
        if(k >= str.length()) return 0;
        int flag = 1;
        if(str.charAt(k) == '-') flag = -1; 
        if(str.charAt(k) == '+' || str.charAt(k) == '-') k++;
        if(k >= str.length()) return 0;
        long res = 0;
        int bounder = Integer.MAX_VALUE / 10;
        while(k < str.length() && str.charAt(k) >= '0' && str.charAt(k) <= '9') {
            if(res > bounder || res == bounder && str.charAt(k) > '7') return flag == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            res = res * 10 + (str.charAt(k) - '0');
            k++;
        }     
        return (int)res * flag;
    }
}
```
# [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return null;
        if(root.val > p.val && root.val > q.val) {
            return lowestCommonAncestor(root.left,p,q);
        } else if(root.val < p.val && root.val < q.val) {
            return lowestCommonAncestor(root.right,p,q);
        }else {
            return root;
        }
    }
}
```
# [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return null;
        if(root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left != null && right != null) return root;
        if(left != null) return left;
        else return right;       
    }
}
```
