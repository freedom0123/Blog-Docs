---
title: 二分
description: 二分模板及示例
sticky: 1
recommend: 1
tag:
 - 算法
---

> 所谓二分算法，就是不断的缩减区间的范围去寻找目标值

## 一、整数二分
### 1.1 模板一

1.  会将区间划分为`[l,mid]` 和`[mid+1,r]`两个区间，最终结果会落在左半区间 
2.  `left指针`和`right指针`最终都会落在相同的点上，可以通过两个指针指向的值判断是否是有解
```java
int l = 0;
int r = n;
while(l < r ){
    int mid = l+r>>1;
    if(check(mid)){
        r = mid;
    }else{
        l = mid+1;
    }
}
```
### 1.2 模板二

1.  会将区间划分为`[l,mid-1] `和`[mid,r]`两个区间，最终结果会落在右半区间 
2.  left指针和right指针最终都会落在相同的点上，可以通过两个指针指向的值判断是否是有解
```java
int l = -1;
int r = n - 1;
while(l < r){
    int mid = l + r + 1 >>1;
    if(check(mid)){
        l = mid;
    }else{
        r = mid-1;
    }
}
```
## 二、浮点数二分
> 这个用的比较少，这里的k指的是题目的精度

```java
double find(int left,int right){
    double eps = le-k+2;
    while(right - left > eps){
        double mid = (right+left)/2;
        if(check(mid)){
            r = mid;
        }else{
            l = mid;
        }
    } 
    reutrn l;
}
```
## 三、如何写出正确的二分

1.  判断题目是否可以使用二分，二分不仅仅适用于单调的序列，而且适用于有二段性的序列 
2.  通过判断答案所落在的区间，选择不同的模板
3.  通过第二步的分析，写出check函数，使得答案边界的更新落在`if`中。
4.  二分终止条件就是 `l == r`, 可以通过l或者是r指向的值是否是预期值，判断有没有解 
## 四、题目汇总
### 704. 二分查找

1. 这是一个有序的数组，查找指定值，满足二分的基本条件。这里是一个升序的数组，只需要判断数组中有无该元素，所以选取模板一和模板二都是可以的。这里只对模板一进行说明
2. 如果说 `r = mid`，那么最终答案会落在左半区间，因为这又是一个升序的数组，如果说mid指向的元素都比目标值大了，那么后面的只可能更大，要想每次让`r = mid`更新，`check`函数就要写成`nums[mid] >= target`
```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0;
        int r = nums.length - 1;
        while(l < r) {
            int mid = (l + r) >> 1;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        return nums[l] == target ? r : -1;

    }
}
```
```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0;
        int r = nums.length - 1;
        while(l < r) {
            int mid = (l + r + 1) >> 1;
            if(nums[mid] <= target) l = mid;
            else r = mid - 1;
        }
        return nums[l] == target ? r : -1;

    }
}
```
### 34. 在排序数组中查找元素的第一个和最后一个位置

> [原题链接](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

一般来说，看到有序的数组，都要去想一想能不能用二分

1.  如果说查找开始位置，在有解的情况之下，一定会落在候选区间的左半边，所以说我们选择`r = mid`的这个模板，那么check函数就顺理成章的写出来了,`nums[mid] >= target`,这样答案就会落在左半区间，那么就得到的就是开始位置 
2.  如果说查找结束位置，与分析开始位置是一致的，在有解的情况之下，一定会落在候选区间的右半边，所以说我们选择`l = mid`的这个模板，那么check函数就是`nums[mid] <= target`,这样答案就会落在右半区间，那么得到的就是结束位置 

**代码**
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
         int[] res = {-1,-1};
        if(nums.length == 0) return res;
        int l = 0;
        int r = nums.length - 1;
        // 寻找开始位置
        while(l < r) {
            int mid = l + r >> 1;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if(nums[l] == target) res[0] = l;
        l = 0;  
        r = nums.length - 1;
        // 寻找结束位置
        while(l < r) {
            int mid = (l + r + 1) >> 1;
            if(nums[mid] <= target) l = mid;
            else r = mid - 1;
        }
        if(nums[l] == target) res[1] = l;
        if(res[0] > res[1]) res[0] = res[1] = -1;
        return res;

    }
}
```
### 69. x 的平方根

> [原题链接](https://leetcode.cn/problems/sqrtx/)

**题目的本质就是在所有小于等于x的数中，选出一个值，使得**`**z * z <= x**`**并且使得z最大，答案最终会落在右半区间，选择模板二。**
```java
class Solution {
    public int mySqrt(int x) {
        long l = 0;
        long r = x;
        while(l < r) {
            long mid = (l + r + 1) >> 1;
            if(mid * mid <= x) {
               l = mid; 
            }else {
                r = mid - 1;
            }
        }
        return (int)l;
    }
}
```

### 33. 搜索旋转排序数组

> [原题链接](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

**思路**
从题目中进行分析，数组中没有重复元素，原来的数组升序的，旋转之后，我们很容易发现，前半段都是大于新数组的第一个数，后半段都是小于新数组的第一个数，仍然具有二段性，可以使用二分。那么说现在就用两个问题，首先，就是如何去寻找这个分界点，其次，就是分界点确定之后，如果去运用我们的二分模板去寻找答案

1.  分界点获取 
   - 遍历:分界点，后面的元素一定是比分界点出的元素小的
   - 二分:整个序列具有二段性，前半段具有大于num[0] 的性质，后半段具有小于num[0]的性质
2.  找到分界点之后，如果说target比第一个元素大，那么答案区间一定在多半段，反之，一定在右半段。不管是那一段，都是单调的，合理分析。既可以得到答案 

**代码**
```java
class Solution {
    public int search(int[] nums, int target) {
        if(nums.length == 0 ){
            return -1;
        }
        int l = 0;
        int r = nums.length - 1;

        while(l < r) {
            int mid = l + r + 1 >> 1;
            if(nums[mid] >= nums[0]) l = mid;
            else r = mid - 1;
        }
        
        if(target >= nums[0]) {
            l = 0;
        }else {  
            l++;
            r = nums.length - 1;
        }
       while(l < r) {
            int mid = l + r >> 1;
            if(nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        return nums[r] == target ? r : -1;

    }
}
```
### 81.搜索旋转排序数组II

**思路**
相比于上题，数组中有了重复元素，使得不具有二段性，而没有二段性的原因就是旋转之后，新数组的头和尾中有了重复元素，如果说取出了这些重复元素，数组就重新具有了二段性，如果说数组尾和数组头是一致的，就压缩数组的右边界，然后就和上题一样的做法，之后就不在赘述
**代码一**
> 直接遍历，时间复杂度 O(n)

```java
class Solution {
    public boolean search(int[] nums, int target) {
        for(int i  = 0;i<nums.length;i++){
            if(nums[i] == target){
                return true;
            }
        }
        return false;
    }
}
```
**代码二**
> 二分，最坏情况下是O(N),相比之下，更加推荐使用代码一，代码量更加短，时间复杂度一致

```java
class Solution {
    public boolean search(int[] nums, int target) {
        if(nums.length == 0){
            return false;
        }
        int R  = nums.length - 1;
        while(R >= 0 && nums[R] == nums[0] ){
            R--;
        }
        if(R < 0) return nums[0] == target;
        
        int r = R;
        int l = 0;
        while(l < r){
            int mid  = l+r+1 >> 1;
            if(nums[mid] >= nums[0]) l = mid;
            else r = mid-1;
        }
        if(target >= nums[0]){
            r = l;
            l = 0;
        }else{
            l++;
            r = R;
        }
        while(l < r){
            int mid  = l+r>>1;
            if(nums[mid]>=target) r = mid;
            else l = mid+1;
        }
        if(nums[r] == target) return true;
        return false;
    }
}
```

